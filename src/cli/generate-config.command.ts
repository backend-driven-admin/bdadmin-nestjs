import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import {
	BDADMIN_AUTH_METADATA,
	BDADMIN_BEHAVIOR_METADATA,
	BDADMIN_ENTITY_METADATA,
	BDADMIN_FIELDS_METADATA,
	BDADMIN_LOGIN_METADATA,
	BDADMIN_LOGOUT_METADATA,
	BDADMIN_REFRESH_METADATA,
	BDADMIN_VALIDATIONS_METADATA,
	type BdAdminAuthOptions,
	type BdAdminBehaviorOptions,
	type BdAdminEndpointType,
	type BdAdminEntityOptions,
	type BdAdminFieldOptions,
	type BdAdminLoginOptions,
	type BdAdminLogoutOptions,
	type BdAdminRefreshOptions,
	type BdAdminValidationOptions,
} from "../interfaces/bdadmin-metadata.interface";
import { join } from "node:path";
import { capitalizeFirstLetter } from "../utils/capitalizeFirstLetter";
import type { Ora } from "ora";

/**
 * BDADMIN Configuration Type.
 * Defines the structure of the configuration object generated by this module.
 */
interface ConfigType {
	entities: Array<
		BdAdminEntityOptions & { endpoint: BdAdminEndpointType } & {
			fields: Array<BdAdminFieldOptions & { key: string }>;
			actions: Array<{
				endpoint: BdAdminEndpointType;
				fields: Array<BdAdminValidationOptions & { key: string }>;
			}>;
		}
	>;
	auth: {
		login?: {
			endpoint: BdAdminEndpointType;
			fields: Array<BdAdminValidationOptions>;
		};
		logout?: BdAdminLogoutOptions & { refreshKey?: string };
		refresh?: BdAdminRefreshOptions;
		settings: {
			accessKey?: string;
			refreshKey?: string;
		};
	};
}

/**
 * Utility function to extract metadata fields from one or more types using a specified metadata key.
 *
 * @param typeOrTypes - A single type or an array of types from which to extract metadata.
 * @param metadataKey - The metadata key used to retrieve the fields.
 * @returns An array of extracted metadata fields.
 */
function extractFieldsFromType(
	typeOrTypes: BdAdminBehaviorOptions["type"],
	metadataKey: string,
): Array<any> {
	const fields: any[] = [];

	const processType = (type: any) => {
		const data = Reflect.getMetadata(metadataKey, type);
		if (data) {
			if (Array.isArray(data)) {
				fields.push(...data);
			} else {
				fields.push(data);
			}
		}
	};

	if (typeof typeOrTypes === "function") {
		processType(typeOrTypes);
	} else if (Array.isArray(typeOrTypes)) {
		typeOrTypes.forEach(processType);
	}

	return fields;
}

/**
 * Generates a BDADMIN configuration object based on provided classes with metadata.
 *
 * @param classes - An array of classes to process for BDADMIN metadata.
 * @param loading
 * @returns A configuration object conforming to ConfigType.
 */
export function generateBdAdminConfig(
	classes: Function[],
	loading: Ora,
): ConfigType {
	const config: ConfigType = {
		entities: [],
		auth: {
			settings: {},
		},
	};

	// Process each class to extract metadata
	for (const cls of classes) {
		const entityMeta: BdAdminEntityOptions | undefined = Reflect.getMetadata(
			BDADMIN_ENTITY_METADATA,
			cls,
		);

		const authMeta: BdAdminAuthOptions | undefined = Reflect.getMetadata(
			BDADMIN_AUTH_METADATA,
			cls,
		);

		const prototype = cls.prototype;
		if (!prototype) continue;

		const methodNames = Object.getOwnPropertyNames(prototype).filter(
			(name) => typeof prototype[name] === "function" && name !== "constructor",
		);

		if (entityMeta) {
			loading.start("Reading entity");
			// Process entity-related metadata
			const behaviors: Array<{
				methodName: string;
				behaviorMeta: BdAdminBehaviorOptions;
			}> = [];

			loading.start("Reading method names");
			for (const methodName of methodNames) {
				const behaviorMeta: BdAdminBehaviorOptions | undefined =
					Reflect.getMetadata(BDADMIN_BEHAVIOR_METADATA, prototype, methodName);
				if (behaviorMeta) {
					behaviors.push({ methodName, behaviorMeta });
				}
			}

			loading.start("Searching for the GET method of an entity");
			const getBehaviorEntry = behaviors.find(
				(entry) => entry.behaviorMeta.endpoint.method === "GET",
			);
			if (!getBehaviorEntry) {
				loading.start(
					"The method for getting entity data was not found. Please refer to the documentation",
				);
				process.exit(1);
			}

			let getFields: Array<BdAdminFieldOptions & { key: string }> = [];
			if (getBehaviorEntry) {
				getFields = extractFieldsFromType(
					getBehaviorEntry.behaviorMeta.type,
					BDADMIN_FIELDS_METADATA,
				);
			}

			loading.start("Creating Entity");
			try {
				config.entities.push({
					...entityMeta,
					endpoint: getBehaviorEntry.behaviorMeta.endpoint,
					fields: getFields.map((f) => ({
						key: f.key,
						type: f.type,
						sort: f.sort,
						search: f.search,
					})),
					actions: [],
				});

				// Process actions for the entity
				const entityIndex = config.entities.findIndex(
					(entity) => entity.name === entityMeta.name,
				);
				if (entityIndex !== -1) {
					for (const { behaviorMeta } of behaviors.filter(
						(entry) => entry !== getBehaviorEntry,
					)) {
						const actionFields = extractFieldsFromType(
							behaviorMeta.type,
							BDADMIN_VALIDATIONS_METADATA,
						);
						config.entities[entityIndex].actions.push({
							endpoint: behaviorMeta.endpoint,
							fields: actionFields.map((f) => ({
								key: f.key,
								type: f.type,
								min: f.min,
								max: f.max,
								required: f.required,
								unique: f.unique,
								hidden: f.hidden,
								disabled: f.disabled,
								defaultValue: f.defaultValue,
								regex: f.regex?.toString(),
								dataSource: f.dataSource,
							})),
						});
					}
				}
			} catch (error) {
				loading.fail("Error when creating entities");
				process.exit(1);
			}
		} else if (authMeta) {
			loading.start("Creating Auth");
			// Process authentication metadata
			config.auth.settings.accessKey = authMeta.accessKey;
			config.auth.settings.refreshKey = authMeta.refreshKey;

			for (const methodName of methodNames) {
				const loginMeta: BdAdminLoginOptions | undefined = Reflect.getMetadata(
					BDADMIN_LOGIN_METADATA,
					prototype,
					methodName,
				);
				const logoutMeta: BdAdminLogoutOptions | undefined =
					Reflect.getMetadata(BDADMIN_LOGOUT_METADATA, prototype, methodName);
				const refreshMeta: BdAdminRefreshOptions | undefined =
					Reflect.getMetadata(BDADMIN_REFRESH_METADATA, prototype, methodName);

				if (loginMeta) {
					config.auth.login = {
						endpoint: loginMeta.endpoint,
						fields: extractFieldsFromType(
							loginMeta.type,
							BDADMIN_VALIDATIONS_METADATA,
						).map((f) => ({
							key: f.key,
							type: f.type,
							min: f.min,
							max: f.max,
							required: f.required,
							unique: f.unique,
							hidden: f.hidden,
							disabled: f.disabled,
							defaultValue: f.defaultValue,
							regex: f.regex?.toString(),
							dataSource: f.dataSource,
						})),
					};
				} else if (logoutMeta) {
					config.auth.logout = {
						endpoint: logoutMeta.endpoint,
					};
				} else if (refreshMeta) {
					config.auth.refresh = {
						endpoint: refreshMeta.endpoint,
					};
				}
			}
		}
	}

	// Ensure that all authentication endpoints are configured
	if (!config.auth.login || !config.auth.refresh || !config.auth.logout) {
		loading.fail(
			"Authentication is not fully configured. Please refer to the documentation.",
		);
		process.exit(1);
	}

	return config;
}

/**
 * Creates a BDADMIN directory structure and writes the configuration file along with required module and controller files.
 *
 * **Steps:**
 * 1. Creates the directory structure in `src/<name>` if it doesn't already exist.
 * 2. Writes the generated configuration file (`config.json`) to `src/<name>/config/`.
 * 3. Generates the `bdadmin.module.ts` and `bdadmin.controller.ts` files.
 * 4. Updates the `app.module.ts` to include the newly created module.
 *
 * @param jsonStr - The JSON string of the BDADMIN configuration.
 * @param name - The name of the directory and module (e.g., "bdadmin").
 * @param loading
 */
function createBdAdminDirectory(jsonStr: string, name: string, loading: Ora) {
	loading.start("Creating a directory");
	try {
		const bdadminDir = join(process.cwd(), "src", name);
		const configDirPath = join(bdadminDir, "config");

		// Create directories if they don't exist
		if (!existsSync(bdadminDir)) {
			mkdirSync(bdadminDir, { recursive: true });
		}
		if (!existsSync(configDirPath)) {
			mkdirSync(configDirPath, { recursive: true });
		}

		// Write the configuration file
		const configFilePath = join(configDirPath, "config.json");
		writeFileSync(configFilePath, jsonStr, "utf-8");

		// Create the module file
		const moduleContent = `import { Module } from '@nestjs/common';
import { ${capitalizeFirstLetter(name)}Controller } from './${name}.controller';

@Module({
  controllers: [${capitalizeFirstLetter(name)}Controller],
})
export class ${capitalizeFirstLetter(name)}Module {}`;
		writeFileSync(
			join(bdadminDir, `${name}.module.ts`),
			moduleContent,
			"utf-8",
		);

		// Create the controller file
		const controllerContent = `import { Controller, Get } from '@nestjs/common';
import * as config from './config/config.json';

@Controller('${name}')
export class ${capitalizeFirstLetter(name)}Controller {
  @Get('config')
  getConfig() {
    return config;
  }
}`;
		writeFileSync(
			join(bdadminDir, `${name}.controller.ts`),
			controllerContent,
			"utf-8",
		);

		// Update the AppModule
		updateAppModule(name, loading);
	} catch (error) {
		loading.fail("Error when creating a directory");
		process.exit(1);
	}
}

/**
 * Updates the `app.module.ts` file to include the newly created BDADMIN module.
 *
 * **Steps:**
 * 1. Reads the content of `app.module.ts`.
 * 2. Checks if the module import already exists.
 * 3. Adds the import statement and updates the `imports` array if necessary.
 *
 * @param name - The name of the module to add (e.g., "bdadmin").
 * @param loading
 */
function updateAppModule(name: string, loading: Ora) {
	loading.start("Updating the app.module.ts");
	try {
		const appModulePath = join(process.cwd(), "src", "app.module.ts");
		const appModuleContent = readFileSync(appModulePath, "utf-8");

		if (!appModuleContent.includes(`${capitalizeFirstLetter(name)}Module`)) {
			const updatedContent = appModuleContent
				.replace(
					"@Module({",
					`import { ${capitalizeFirstLetter(name)}Module } from './${name}/${name}.module';\n\n@Module({`,
				)
				.replace(
					"imports: [",
					`imports: [${capitalizeFirstLetter(name)}Module, `,
				);

			writeFileSync(appModulePath, updatedContent, "utf-8");
		}
		loading.succeed(
			`The config was successfully generated on the path /src/${name}`,
		);
	} catch (error) {
		loading.fail("Couldn't update app.module.ts");
		process.exit(1);
	}
}

/**
 * Generates a BDADMIN configuration file in JSON format.
 *
 * **Steps:**
 * 1. Processes classes to extract metadata.
 * 2. Generates a configuration object.
 * 3. Writes the configuration to a file or creates a full BDADMIN module.
 *
 * @param classes - An array of classes to process for BDADMIN metadata.
 * @param loading
 * @param isLocal - Whether to generate only the configuration file locally (true) or create a full module (false).
 * @param name - The name of the directory and module for the generated files.
 */
export function generateBdAdminConfigFile(
	classes: Function[],
	loading: Ora,
	isLocal: boolean,
	name: string,
) {
	const config = generateBdAdminConfig(classes, loading);
	const jsonStr = JSON.stringify(config, null, 2);

	if (isLocal) {
		// Write only the config file
		loading.start("Generating a local config");
		try {
			const outputPath = join(process.cwd(), "bdadmin.config.json");
			writeFileSync(outputPath, jsonStr, "utf-8");
			loading.succeed(
				`The config was successfully generated on the path ${outputPath}`,
			);
		} catch (error) {
			loading.fail("Couldn't generate a local config");
			process.exit(1);
		}
	} else {
		// Create the BDADMIN directory structure and files
		createBdAdminDirectory(jsonStr, name, loading);
	}
}
